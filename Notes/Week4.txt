On Debian-based systems, temporary root files system (initramfs) can be created with "update-initramfs".

By default, make install command copies:
-Kernel image -> /boot/ vmlinuz-<kernel_version>
-Kernel symbol table -> /boot/System.map-<kernel_version>
-module files -> /lib/modules/<kernel_version>/kernel/
-.config -> file /boot/config-kernelversion
-temp root fs -> boot/initrd.img-<kernelversion> (can be created with update-initramfs)

initrd.im can be viewed with the "cpio -idv < filename" command. However, in case this file is compressed, it's smart to check the
type of file with the command "file". If it is a compressed file, it needs to be uncompressed with the proper command first. cpio
is an archive format that is used for the temp root fs used during boot. Just like tar, cpio simply adds files one after the other. It
should be noted that the contents of this file can change between distros.

-------------------------------------------------------------------------------------------------------------------------------------
make install does everything necessary to update the GRUB to open up with the new kernel. If GRUB menu needs to show up on every time
the computer is booted, the following changes need to be written to /etc/default/grub:

GRUB_TIMEOUT_STYLE=menu
GRUB_TIMEOUT=5

Once these changes are made, GRUB bootloader can be updated with:

sudo update-grub

These operations can also be done via the program "grub-customizer", which needs to be installed on the system.
-------------------------------------------------------------------------------------------------------------------------------------

The version of the kernel image isn't just the name of the file, it is actually written inside the compiled kernel image. This means
we need to have a filename that matches the string inside the kernel image. In case you forget what name you gave to the image and
therefore don't know what string is compiled into the kernel image, this can be checked with the command
"strings vmlinux | grep "Linux version"" by running the command where the kernel image is.

As seen so far, it is very .... to do all of this by hand. The easiest way really is just running "make modules_install" and then
"make install". This way, everything is handled automatically.
A little reminder: "make modules" just compiles all the modules. "make modules_install" also copies the compiled files into necessary
places. If all of the modules can be compiled without any errors, there are no problems using make modules_install directly.

STEPS OF COMPILATION:
---------------------
1) Install necessary tools for compilation
2) Download and extract kernel codes from kernel.org
3) Copy config files from /boot into the kernel source root with the name .config
4) Use "make menuconfig" to change .config
5) If kernel doesn't need a signature, previously discussed configurations are made (either manually or with make menuconfig)
6) Kernel is compiled with "make -j$(nproc)"
7) Modules and relevant files are copied to their places with "sudo make modules_install"
8) Kernel image and relevant files are copied to their places with "sudo make install"

HOW TO CHANGE KERNEL CODES:
---------------------------
1) Changing the existing kernel functions
2) Adding a new function to the existing kernel files
3) Adding a new C file into a directory in the kernel source
4) Adding a new directory to the kernel source and adding new files into it

For 1 and 2, make files doesn't need to be changed. For 3 and 4, respsective makefile needs to be modified so that it is aware of the
new codes.

Adding a new C file:
--------------------------------------------------------------------------------------------------------------------------------------
If a new file will be added to an existing directory, a line with the following format needs to be added at the makefile in that
directory. This line can be added to the very end.

obj-y+=<source_code_file_name>.o

Adding a new directory with files in it:
--------------------------------------------------------------------------------------------------------------------------------------
If a new directory is being added with source code files in it, the makefile in the directory that the new directory is created in
needs to be edited to add the following line. The line can be added to the very end.

obj-y+=<directory_name>/

Then, a new makefile with the name "Makefile" needs to be created in the newly created directory, and for each source code file in it,
the "obj-y+=<source_code_file_name>.o" line needs to be added to the new makefile.

+= in Make
----------
X = VALUE
#Value of X is VALUE here
#... some other codes
X += VALUE2
#Value of X here is VALUE VALUE2. Make adds the space automatically, which is important for file names.
#So basically, += in Make concatenates two strings with a space in between them.

Linux's build system is called KBuild or KConfig.

"dmesg" command can be used to get the kernel logs (a.k.a. logs printed from kernel using printk).

Instead of obj-y, we can also write obj-m, which means the file is a driver (y is for yes, m is for module). If a file is appended
with obj-y, this means the compiled code will be embedded inside the kernel image. However, if obj-m is used, this means the file
will be compiled as a separate module and not be embedded inside the kernel image. obj-m can also be used for the newly created
directories. So "obj-m += folder_name/" is perfectly permissible.

The .c files always needs a newline at the end of the file (idky the tutor just said that's what we should do lol)

OPTIONS IN make menuconfig:
---------------------------
 [] means that option can be included or excluded. [] means excluded, [*] means included.
 --- or -*- means the value of that option cannot be changed.
 <> means it can be included, excluded or modularized (compiled as a module). This is called "tristate" (üç konumlu seçenek).
 () means that option can be given a value, such as a numeric value

Once the menuconfig generates the .config file, during build, the build system generates a file called "autoconf.h". This file
contains #define of the configurations in the .config file and their values are the same as it is defined in the .config file. This
allows C codes to be able to get the values in the .config file and use them to achieve conditional compilation. autoconf.h isn't
advised to be manually edited, although it can be done.
NOTE: The path of autoconf.h is include/generated/autoconf.h

If the value of a given option is "y" or "m", in the #define statement of the autoconf.h, the value of that option will be set to 1.
Meaning, anything with [*], <*> or <M>, the value will be 1. Otherwise ("n", meaning [] or <>), that #define won't be generated at
all. If a value is given with (), then the value of the #define will be the value inside the paranthesis.

In order to find out what the name of the #define will be when autoconf.h is generated, the option in the make menuconfig provides
an information menu about the option that provides that name, among other things. This menu can be accessed through by selecting the
option in the make menuconfig.

In order to use these values, the kernel codes can use #ifdef and #ifndef preprocessor directives.

HOW IS THAT OPTION GIVEN TO THE MAKEFILES?
------------------------------------------
This section has to do with the obj-$(CONFIG_NAME) lines. The $(CONFIG_NAME) expands to "y", "n" or "m", which causes the relevant
file to either be compiled or not, and whether to be embedded in the kernel or modularized. If the value is "n", the build system will
either not generate the relevant line for that CONFIG_NAME, or will add it to the obj-n variable. Which one happens changes depending
on the situation. Since obj-n either doesn't exist or ignored, either one just means disabling that part of the kernel.

It is important not to confuse these with the #define codes for the C part. These are Makefile variables and cannot be used from C.
Similarly, #define codes for C cannot be used by Makefile files either.

Sometimes, system programmers, can add the following line manually, which has the same effect as obj-y += mysyscall.o:

ifeq ($(CONFIG_MYSYSCALL), y)
    obj-y += mysyscall.o
endif